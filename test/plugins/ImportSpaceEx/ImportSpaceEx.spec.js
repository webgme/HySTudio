/*eslint-env node, mocha*/
/**
 * Generated by PluginGenerator 2.20.5 from webgme on Tue Dec 11 2018 12:39:14 GMT-0600 (Central Standard Time).
 */

describe('ImportSpaceEx', function () {
    var testFixture = require('../../globals'),
        gmeConfig = testFixture.getGmeConfig(),
        expect = testFixture.expect,
        logger = testFixture.logger.fork('ImportSpaceEx'),
        PluginCliManager = testFixture.WebGME.PluginCliManager,
        projectName = 'testProject',
        importPluginName = 'ImportSpaceEx',
        exportPluginName = 'ExportSpaceEx',
        Hyst = testFixture.requirejs('hysteditor/HyST'),
        Q = testFixture.Q,
        fs = testFixture.fs,
        path = testFixture.path,
        bc,
        core,
        rootHash,
        project,
        gmeAuth,
        storage,
        commitHash;

    function removeGraphicalElements(modelObject) {
        var elementsToRemove = ['labelposition', 'note', 'middlepoint'],
            attributesToRemove = ['x', 'y', 'width', 'height', 'width', 'bezier'],
            removeElement = function (modelElement, elementName) {
                var keys;

                if (modelElement instanceof Array) {
                    modelElement.forEach(function (element) {
                        removeElement(element, elementName);
                    });
                } else if (typeof modelElement === 'object') {
                    delete modelElement[elementName];
                    keys = Object.keys(modelElement);
                    keys.forEach(function (key) {
                        if (typeof modelElement[key] === 'object') {
                            removeElement(modelElement[key], elementName);
                        }
                    });
                }
            },
            removeAttribute = function (modelElement, attributeName) {
                var keys;

                if (modelElement instanceof Array) {
                    modelElement.forEach(function (element) {
                        removeAttribute(element, attributeName);
                    });
                } else if (typeof modelElement === 'object') {
                    Hyst.delAttribute(modelElement, attributeName);
                    keys = Object.keys(modelElement);
                    keys.forEach(function (key) {
                        if (typeof modelElement[key] === 'object') {
                            removeAttribute(modelElement[key], attributeName);
                        }
                    });
                }
            };

        elementsToRemove.forEach(function (elementName) {
            removeElement(modelObject, elementName);
        });

        attributesToRemove.forEach(function (attributeName) {
            removeAttribute(modelObject, attributeName);
        });
    }

    function testImportExport(filename, done) {
        var manager = new PluginCliManager(null, logger, gmeConfig),
            pluginConfig = {},
            newHash,
            newRoot,
            fileContent = fs.readFileSync(path.join(process.cwd(), 'test/assets/' + filename + '.xml'), 'utf8'),
            context = {
                project: project,
                commitHash: commitHash,
                activeNode: '/v',
                namespace: 'SpaceEx'
            };

        bc.putFile(filename + '.xml', fileContent)
            .then(function (hash) {
                pluginConfig.modelFile = hash;
                return Q.ninvoke(manager, 'executePlugin', importPluginName, pluginConfig, context);
            })
            .then(function (result) {
                expect(typeof result).to.equal('object');
                expect(result.success).to.equal(true);
                expect(result.commits).to.have.length(2);
                newHash = result.commits[1].commitHash;
                return testFixture.loadRootNodeFromCommit(project, core, newHash);
            })
            .then(function (root) {
                expect(root).not.to.equal(null);

                newRoot = root;
                return core.loadByPath(root, '/v');
            })
            .then(function (modelContainer) {
                var childrenPaths,
                    path;

                expect(modelContainer).not.to.equal(null);

                childrenPaths = core.getChildrenPaths(modelContainer);
                expect(childrenPaths).to.have.length(2);

                childrenPaths.forEach(function (childPath) {
                    if (childPath !== '/v/W') {
                        path = childPath;
                    }
                });
                context.activeNode = path;
                context.commitHash = newHash;

                return Q.ninvoke(manager, 'executePlugin', exportPluginName, {}, context);
            })
            .then(function (result) {
                expect(result).not.to.equal(null);
                expect(result.success).to.equal(true);
                expect(result.artifacts).to.have.length(1);

                return bc.getObjectAsString(result.artifacts[0]);
            })
            .then(function (exportedXml) {
                var inModel,
                    outModel;

                inModel = Hyst.spaceExToJson(fileContent);
                outModel = Hyst.spaceExToJson(exportedXml);
                removeGraphicalElements(inModel);
                removeGraphicalElements(outModel);

                expect(inModel).to.eql(outModel);
            })
            .nodeify(done);
    }

    before(function (done) {
        testFixture.clearDBAndGetGMEAuth(gmeConfig, projectName)
            .then(function (gmeAuth_) {
                gmeAuth = gmeAuth_;
                // This uses in memory storage. Use testFixture.getMongoStorage to persist test to database.
                storage = testFixture.getMemoryStorage(logger, gmeConfig, gmeAuth);
                return storage.openDatabase();
            })
            .then(function () {
                var importParam = {
                    projectSeed: path.join(process.cwd(), 'test/assets/testEmpty.webgmex'),
                    projectName: projectName,
                    branchName: 'master',
                    logger: logger,
                    gmeConfig: gmeConfig
                };

                return testFixture.importProject(storage, importParam);
            })
            .then(function (importResult) {
                project = importResult.project;
                commitHash = importResult.commitHash;
                bc = importResult.blobClient;
                rootHash = importResult.rootHash;
                core = importResult.core;
            })
            .nodeify(done);
    });

    after(function (done) {
        storage.closeDatabase()
            .then(function () {
                return gmeAuth.unload();
            })
            .nodeify(done);
    });

    it('should import without any error', function (done) {
        var manager = new PluginCliManager(null, logger, gmeConfig),
            pluginConfig = {},
            newHash,
            newRoot,
            fileContent = fs.readFileSync(path.join(process.cwd(), 'test/assets/circle.xml'), 'utf8'),
            context = {
                project: project,
                commitHash: commitHash,
                branchName: 'master',
                activeNode: '/v'
            };

        bc.putFile('model.xml', fileContent)
            .then(function (hash) {
                pluginConfig.modelFile = hash;
                return Q.ninvoke(manager, 'executePlugin', importPluginName, pluginConfig, context);
            })
            .then(function (result) {
                expect(typeof result).to.equal('object');
                expect(result.success).to.equal(true);

                return project.getBranchHash('master');
            })
            .then(function (hash) {
                expect(hash).to.not.equal(commitHash);
                newHash = hash;
                return testFixture.loadRootNodeFromCommit(project, core, hash);
            })
            .then(function (root) {
                expect(root).not.to.equal(null);

                newRoot = root;
                return core.loadByPath(root, '/v');
            })
            .then(function (modelContainer) {
                var childrenPaths,
                    path;

                expect(modelContainer).not.to.equal(null);

                childrenPaths = core.getChildrenPaths(modelContainer);
                expect(childrenPaths).to.have.length(2);

                childrenPaths.forEach(function (childPath) {
                    if (childPath !== '/v/W') {
                        path = childPath;
                    }
                });
                return core.loadByPath(newRoot, path);
            })
            .then(function (newModel) {
                expect(newModel).not.to.equal(null);
                return project.setBranchHash('master', commitHash, newHash);
            })
            .nodeify(done);
    });

    it('should import+export and have the same xml', function (done) {
        var manager = new PluginCliManager(null, logger, gmeConfig),
            pluginConfig = {},
            newHash,
            newRoot,
            fileContent = fs.readFileSync(path.join(process.cwd(), 'test/assets/circle.xml'), 'utf8'),
            context = {
                project: project,
                commitHash: commitHash,
                branchName: 'master',
                activeNode: '/v',
                namespace: 'SpaceEx'
            };

        bc.putFile('circle_model.xml', fileContent)
            .then(function (hash) {
                pluginConfig.modelFile = hash;
                return Q.ninvoke(manager, 'executePlugin', importPluginName, pluginConfig, context);
            })
            .then(function (result) {
                expect(typeof result).to.equal('object');
                expect(result.success).to.equal(true);

                return project.getBranchHash('master');
            })
            .then(function (hash) {
                expect(hash).to.not.equal(commitHash);
                newHash = hash;
                return testFixture.loadRootNodeFromCommit(project, core, hash);
            })
            .then(function (root) {
                expect(root).not.to.equal(null);

                newRoot = root;
                return core.loadByPath(root, '/v');
            })
            .then(function (modelContainer) {
                var childrenPaths,
                    path;

                expect(modelContainer).not.to.equal(null);

                childrenPaths = core.getChildrenPaths(modelContainer);
                expect(childrenPaths).to.have.length(2);

                childrenPaths.forEach(function (childPath) {
                    if (childPath !== '/v/W') {
                        path = childPath;
                    }
                });
                context.activeNode = path;
                context.commitHash = newHash;

                return Q.ninvoke(manager, 'executePlugin', exportPluginName, {}, context);
            })
            .then(function (result) {
                expect(result).not.to.equal(null);
                expect(result.success).to.equal(true);
                expect(result.artifacts).to.have.length(1);

                return bc.getObjectAsString(result.artifacts[0]);
            })
            .then(function (exportedXml) {
                var inModel = Hyst.spaceExToJson(fileContent),
                    outModel = Hyst.spaceExToJson(exportedXml);

                removeGraphicalElements(inModel);
                removeGraphicalElements(outModel);

                expect(inModel).to.eql(outModel);
            })
            .then(function (result) {
                return project.setBranchHash('master', commitHash, newHash);
            })
            .nodeify(done);
    });

    it('should import+export and have the same xml - bbal', function (done) {
        testImportExport('bball', done);
    });

    it('should import+export and have the same xml - 3d-stable', function (done) {
        testImportExport('3d_stable', done);
    });

    it('should import+export and have the same xml - heli', function (done) {
        testImportExport('heli', done);
    });

    it('should import+export and have the same xml - toy', function (done) {
        testImportExport('toy', done);
    });

    it('should import+export and have the same xml - vanderpol', function (done) {
        testImportExport('vanderpol', done);
    });

    it('should import+export and have the same xml - heli-large', function (done) {
        testImportExport('heli_large', done);
    });

    it('should import+export and have the same xml - vanderpol-det', function (done) {
        testImportExport('vanderpol_deterministic', done);
    });

    it.only('should import+export and have the same xml - heaterLygeros', function (done) {
        testImportExport('heaterLygeros', done);
    });

    it('should import+export and have the same xml - bball_timed', function (done) {
        testImportExport('bball_timed', done);
    });
});
