/*globals define, WebGMEGlobal*/
/*jshint browser: true*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Thu Jan 03 2019 20:58:44 GMT-0600 (Central Standard Time).
 */

define(['js/Constants',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames',
    'js/Toolbar/ToolbarSeparator',
    'js/Toolbar/ToolbarDropDownButton',
    'text!routers/HyST/availableAnalyzers',
    'js/Dialogs/PluginConfig/PluginConfigDialog',
    'blob/BlobClient',
    './AnalyzerResultDialog',
    'js/Loader/ProgressNotification'
], function (CONSTANTS,
             GMEConcepts,
             nodePropertyNames,
             Toolbarseprator,
             ToolbarDropDownButton,
             availableAnalyzers,
             PluginconfigDialog,
             BlobClient,
             AnalyzerResultDialog,
             ProgressNotification) {

    'use strict';

    var AnalyzerToolboxControl;

    AnalyzerToolboxControl = function (options) {

        this._logger = options.logger.fork('Control');

        this._client = options.client;

        this._currentNodeId = null;
        this._currentNodeParentId = undefined;

        this._lastResult = null;

        this._analyzers = JSON.parse(availableAnalyzers);

        this._logger.debug('ctor finished');
    };

    AnalyzerToolboxControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
        var metaNodes = this._client.getAllMetaNodes(),
            name2node = {},
            base,
            newState = {},
            notificationOption = {},
            node = this._client.getNode(activeObjectId);

        metaNodes.forEach(function (metaNode) {
            name2node[metaNode.getAttribute('name')] = metaNode;
        });

        if (this._currentNodeId === activeObjectId) {
            // The same node selected as before - do not trigger
        } else {

            if (node) {
                base = this._client.getNode(node.getBaseId());
                if (node.isTypeOf(name2node['BaseComponent'].getId()) && !node.isMetaNode() && base && !base.isMetaNode()) {
                    //we need to switch to the template and notify the user about it
                    notificationOption.message = 'Currently editing template [' + base.getAttribute('name') + '] as editing instance content is unsafe.';
                    $.notify(notificationOption, {
                        delay: 2000,
                        type: 'info',
                        placement: {
                            from: 'top',
                            align: 'center'
                        }
                    });

                    newState[CONSTANTS.STATE_ACTIVE_OBJECT] = base.getId();
                    WebGMEGlobal.State.set(newState);
                } else if (node.isTypeOf(name2node['Model'].getId())) {
                    // TODO only shows when the component config tells so
                    this._displayToolbarItems();
                } else {
                    this._hideToolbarItems();
                }
            }

        }
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    AnalyzerToolboxControl.prototype.destroy = function () {
        this._detachClientEventListeners();
        this._removeToolbarItems();
    };

    AnalyzerToolboxControl.prototype._attachClientEventListeners = function () {
        this._detachClientEventListeners();
        WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
    };

    AnalyzerToolboxControl.prototype._detachClientEventListeners = function () {
        WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
    };

    AnalyzerToolboxControl.prototype.onActivate = function () {
        this._attachClientEventListeners();
        this._displayToolbarItems();

        if (typeof this._currentNodeId === 'string') {
            WebGMEGlobal.State.registerSuppressVisualizerFromNode(true);
            WebGMEGlobal.State.registerActiveObject(this._currentNodeId);
            WebGMEGlobal.State.registerSuppressVisualizerFromNode(false);
        }
    };

    AnalyzerToolboxControl.prototype.onDeactivate = function () {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    AnalyzerToolboxControl.prototype._abortExecution = function () {
        if (this._executionId) {
            this._client.abortPlugin(this._executionId);
        } else {
            this._aborted = true;
        }
    };

    AnalyzerToolboxControl.prototype._executing = function (executing, analyzerId) {
        var self = this;
        this._aborted = false;
        if (executing) {
            var notif = {
                title: 'Running [' + analyzerId + '] analyzer ...',
                message: '(click here to abort execution)'
            };
            // this._progress = ProgressNotification.start('Running [' + analyzerId + '] analyzer ...');
            this._progress = ProgressNotification.start(notif);
            $(this._progress.note.$ele).find('[data-notify="message"]').click(function () {
                self._abortExecution();
            });
            this._toolbarButton.enabled(false);
        } else {
            this._progress.note.update({
                title: 'Execution of [' + analyzerId + '] finished!',
                message: '',
                progress: 100
            });
            this._progress.note.close();
            this._executionId = null;
            this._toolbarButton.enabled(true);
        }
    };
    AnalyzerToolboxControl.prototype._extendPluginConfig = function (analyzerId, rawConfig) {
        var config = {userOptions: rawConfig};
        //TODO these are added on the server
        // config.workingDir = this._analyzers[analyzerId].workingDir;
        // config.commands = this._analyzers[analyzerId].commands;
        // config.input = this._analyzers[analyzerId].input;
        // config.dockerImage = this._analyzers[analyzerId].dockerImage;
        // config.needConfigFile = this._analyzers[analyzerId].useConfig;
        // config.noConversion = this._analyzers[analyzerId].noConversion;
        config.analyzer = analyzerId;

        return config;
    };

    AnalyzerToolboxControl.prototype._executePlugin = function (analyzerId, config) {
        var self = this,
            context = this._client.getCurrentPluginContext('DockerAnalysisExecuter'),
            bc = new BlobClient({logger: self._logger.fork('BlobClient')}),
            notificationOption = {},
            notificationType = 'success',
            pluginInitiated = function (sender, event) {
                self._client.removeEventListener(self._client.CONSTANTS.PLUGIN_INITIATED, pluginInitiated);
                self._executionId = event.executionId;
                if (self._aborted) {
                    self._aborted = false;
                    self._abortExecution();
                }
            };

        context.pluginConfig = config;
        context.managerConfig.namespace = 'SpaceEx'; //FIXME should be read from the project
        self._executing(true, analyzerId);
        self._client.addEventListener(self._client.CONSTANTS.PLUGIN_INITIATED, pluginInitiated);
        self._client.runServerPlugin('DockerAnalysisExecuter', context, function (err, result) {
            self._executing(false, analyzerId);
            var params;

            result = result || {};
            result.artifacts = result.artifacts || [];

            params = {
                success: err ? false : true,
                err: err,
                id: analyzerId,
                content: result.artifacts.length > 0 ? bc.getDownloadURL(result.artifacts[0]) : null,
                figures: null
            };

            result.artifacts.forEach(function (artifact, index) {
                if (index > 0) {
                    params.figures = params.figures || [];
                    params.figures.push(bc.getDownloadURL(artifact));
                }
            });

            /*
            if (err) {
                self._logger.error(err);
                notificationType = 'danger';
                if (result.artifacts.length > 0) {
                    notificationOption.message = 'Analysis [' + analyzerId + '] ended in error [' +
                        err.message + '] (click to download artifacts).';
                    notificationOption.url = bc.getDownloadURL(result.artifacts[0]);
                    notificationOption.target = '_blank';
                } else {
                    notificationOption.message = 'Analysis [' + analyzerId + '] ended in error [' +
                        err.message + '].';
                }
            } else {
                notificationOption.message = 'Analysis [' + analyzerId + '] finished (click to download artifacts).';
                notificationOption.url = bc.getDownloadURL(result.artifacts[0]);
                notificationOption.target = '_blank';
            }

            self._lastResult = {
                option: notificationOption, config: {
                    delay: 1000,
                    type: notificationType,
                    placement: {
                        from: 'top',
                        align: 'center'
                    },
                    mouse_over: 'pause'
                }
            };

            $.notify(notificationOption, {
                delay: 10000,
                type: notificationType,
                placement: {
                    from: 'top',
                    align: 'center'
                },
                mouse_over: 'pause'
            });
            */
            self._lastResult = params;
            self._showResult(params);
        });
    };

    AnalyzerToolboxControl.prototype._runAnalyzer = function (analyzerId) {
        var self = this,
            dialog = new PluginconfigDialog({client: self._client}),
            pluginMetadata = {
                id: analyzerId,
                name: analyzerId,
                version: '0.4.2',
                description: this._analyzers[analyzerId].description || '',
                disableServerSideExecution: false,
                disableBrowserSideExecution: true,
                dependencies: [],
                writeAccessRequired: false,
                configStructure: []
            };

        if (this._analyzers[analyzerId].userOptions) {
            pluginMetadata.configStructure = this._analyzers[analyzerId].userOptions;
            dialog.show([], pluginMetadata,
                this._analyzers[analyzerId].prevConfig || [], function (oked, config, save) {
                    if (oked !== false) {
                        if (save === true) {
                            self._analyzers[analyzerId].prevConfig = config;
                        } else {
                            self._analyzers[analyzerId].prevConfig = [];
                        }
                        self._executePlugin(analyzerId, self._extendPluginConfig(analyzerId, config));
                    }
                });
        } else {
            self._executePlugin(analyzerId, self._extendPluginConfig(analyzerId, {}));
        }

    };

    AnalyzerToolboxControl.prototype._showResult = function (params) {
        var dialog = new AnalyzerResultDialog();
        dialog.show(params);
    };

    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    AnalyzerToolboxControl.prototype._displayToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    AnalyzerToolboxControl.prototype._hideToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].hide();
            }
        }
    };

    AnalyzerToolboxControl.prototype._removeToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].destroy();
            }
        }
    };

    // TODO this is a hacky way of prepending a single dropdown toolbar button
    AnalyzerToolboxControl.prototype._initializeToolbar = function () {
        var self = this,
            toolBar = WebGMEGlobal.Toolbar,
            separator = new Toolbarseprator(),
            mainButton = new ToolbarDropDownButton({
                title: 'Select the Analysis tool to run on the given Model',
                icon: 'glyphicon glyphicon-font'
            }),
            keys = Object.keys(self._analyzers || {});

        keys.forEach(function (analyzerId) {
            self._analyzers[analyzerId].button = mainButton.addButton({
                title: self._analyzers[analyzerId].description || 'run ' + analyzerId,
                text: analyzerId,
                clickFn: function (/*data*/) {
                    self._runAnalyzer(analyzerId);
                }
            });
        });
        mainButton.addDivider();
        mainButton.addButton({
            title: 'Show the last result',
            text: '- last result -',
            clickFn: function (/*data*/) {
                if (self._lastResult) {
                    self._showResult(self._lastResult);
                } else {
                    $.notify({
                        message: 'This client session has no recent execution results.'
                    }, {
                        delay: 1000,
                        type: 'danger',
                        placement: {
                            from: 'top',
                            align: 'center'
                        },
                        mouse_over: 'pause'
                    });
                }
            }
        });
        this._toolbarItems = [];

        toolBar._el.prepend(separator.el);
        toolBar._el.prepend(mainButton.el);

        this._toolbarItems.push(mainButton);
        this._toolbarItems.push(separator);
        this._toolbarInitialized = true;
        this._toolbarButton = mainButton;
    };

    return AnalyzerToolboxControl;
});
