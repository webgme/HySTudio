/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Wed Dec 19 2018 09:44:52 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'q'
], function (PluginConfig,
             pluginMetadata,
             PluginBase,
             Q) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of HyST.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin HyST.
     * @constructor
     */
    function HyST() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    HyST.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    HyST.prototype = Object.create(PluginBase.prototype);
    HyST.prototype.constructor = HyST;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    HyST.prototype.main = function (callback) {
        var self = this,
            core = self.core,
            config = self.getCurrentConfig(),
            model = self.activeNode;

        self._fs = require('fs');
        self._cp = require('child_process');
        self._path = require('path');
        self._basedir = self._path.join(process.cwd(), 'work_temp');
        self._hystdir = self._path.join(process.cwd(), '/src/plugins/HyST');

        self._modelName = core.getAttribute(model, 'name');
        self._tool = config.tool || 'flowstar';

        self._resultExtenstion = '.out';

        switch (self._tool) {
            case 'flowstar':
                self._resultExtenstion = '.flow';
                break;
            case 'dreach':
                self._resultExtenstion = '.drh';
                break;
            case 'spaceex':
                self._resultExtenstion = '.out.xml';
                break;
            case 'hycomp':
                self._resultExtenstion = '.hydi';
                break;
            case 'hycreate':
                self._resultExtenstion = '.hycreate';
        }

        self._getDirectory();
        self.invokePlugin('ExportSpaceEx', null)
            .then(function (result) {
                if (result.success !== true) {
                    throw new Error('Unable to generate initial format from model!');
                }

                self._fs.writeFileSync(
                    self._path.join(self._workdir, self._modelName + '.xml'),
                    result.pluginInstance._result.content,
                    'utf8'
                );

                return self.getConfigAsString();
            })
            .then(function (configString) {
                self._configFile = {name: self._modelName + '.cfg', content: configString};
                self._fs.writeFileSync(self._path.join(self._workdir, self._modelName + '.cfg'), configString);

                return Q.ninvoke(self._cp, 'exec', 'java -jar ' + self._path.join(self._hystdir, 'Hyst.jar') +
                    ' -i ' + self._path.join(self._workdir, self._modelName + '.xml') + ' -t ' + self._tool
                    + ' " " -debug -o ' + self._path.join(self._workdir, self._modelName + self._resultExtenstion));
            })
            .then(function (stdout) {
                self.logger.debug('stdout');
                self._result = {};
                self._result.filename = self._modelName + self._resultExtenstion;
                self._result.content = self._fs.readFileSync(
                    self._path.join(self._workdir, self._result.filename),
                    'utf8'
                );

                return self.blobClient.putFile(
                    self._result.filename,
                    self._result.content
                );

            })
            .then(function (resulthash) {
                self.result.addArtifact(resulthash);

                self._fs.readdirSync(self._workdir).forEach(function (file) {
                    self._fs.unlinkSync(self._path.join(self._workdir, file));
                });
                self._fs.rmdirSync(self._workdir);

                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                self.logger.error(err);
                self.logger.error(err.stack);
                callback(err, self.result);
            })

    };

    HyST.prototype._getDirectory = function () {
        var chars = 'zxcvbnmasdfghjklqwertyuiop1234567890_',
            iterations = 20,
            dirname = '',
            workdir;
        while (iterations--) {
            dirname += chars.charAt(Math.trunc(Math.random() * chars.length));
        }

        workdir = this._path.join(this._basedir, dirname);
        this._fs.mkdirSync(workdir);
        this._workdir = workdir;
    };

    HyST.prototype._clearWork = function () {
        this._fs.rmdirSync(this._workdir);
    };

    HyST.prototype.getConfigAsString = function () {
        var self = this,
            deferred = Q.defer(),
            config = this.getCurrentConfig(),
            core = this.core,
            model = this.activeNode;

        if (config.configFile) {
            return this.blobClient.getObjectAsString(config.configFile);
        } else {
            core.loadChildren(model)
                .then(function (children) {
                    var configObject = null;
                    children.forEach(function (child) {
                        if (core.isInstanceOf(child, self.META.Configuration)) {
                            configObject = child;
                        }
                    });
                    if (configObject === null) {
                        throw new Error('Cannot find any configration.');
                    }

                    return self.invokePlugin('ExportSpaceExConfig', {activeNode: configObject});
                })
                .then(function (result) {
                    if (result.success !== true) {
                        throw new Error('Unable to generate config file.');
                    }

                    return self.blobClient.getObjectAsString(result.artifacts[0]);
                })
                .then(deferred.resolve)
                .catch(deferred.reject);
        }

        return deferred.promise;
    };

    return HyST;
});
